module ALU (
    input  logic [31:0] A,      // Primer operando
    input  logic [31:0] B,      // Segundo operando
    input  logic [4:0]  M,      // Código de operación (de 0 a 18)
    output logic [31:0] result  // Resultado de la operación
);
    always_comb begin
        case (M)
            5'd0:  result = A + B;       // Suma
            5'd1:  result = A - B;       // Resta A - B
            5'd2:  result = B - A;       // Resta B - A
            5'd3:  result = A & B;       // AND lógico
            5'd4:  result = A | B;       // OR lógico
            5'd5:  result = A ^ B;       // XOR lógico
            5'd6:  result = ~A;          // NOT A
            5'd7:  result = ~B;          // NOT B
            5'd8:  result = A * B;       // Multiplicación
            5'd9:  result = (B != 0) ? A / B : 32'hFFFFFFFF; // División (con control de división por 0)
            5'd10: result = A << 1;      // Desplazamiento a la izquierda
            5'd14: result = fibonacci(A); // Fibonacci
            5'd15: result = factorial(A); // Factorial
            5'd16: result = potencia(A, B); // Potencia A^B
            5'd17: result = (B != 0) ? A % B : 32'hFFFFFFFF; // Módulo (con control de división por 0)
            5'd18: result = raizCuadrada(A); // Raíz cuadrada
            default: result = 0;
        endcase
    end

    // Función para calcular Fibonacci de forma recursiva
    function automatic logic [31:0] fibonacci(input logic [31:0] n);
        if (n == 0) return 0;
        else if (n == 1) return 1;
        else return fibonacci(n - 1) + fibonacci(n - 2);
    endfunction

    // Función para calcular factorial
    function automatic logic [31:0] factorial(input logic [31:0] n);
        logic [31:0] i, res;
        res = 1;
        for (i = 1; i <= n; i = i + 1) begin
            res = res * i;
        end
        return res;
    endfunction

    // Función para calcular potencia A^B
    function automatic logic [31:0] potencia(input logic [31:0] base, input logic [31:0] exp);
        logic [31:0] res;
        res = 1;
        while (exp > 0) begin
            res = res * base;
            exp = exp - 1;
        end
        return res;
    endfunction

    // Función para calcular la raíz cuadrada usando sumas sucesivas
    function automatic logic [31:0] raizCuadrada(input logic [31:0] n);
        logic [31:0] res, impar;
        res = 0;
        impar = 1;
        while (n >= impar) begin
            n = n - impar;
            impar = impar + 2;
            res = res + 1;
        end
        return res;
    endfunction
endmodule

// Módulo para leer el código de operación desde un archivo "Comandos.txt"
module FileReader;
    int file;
    int M;
    
    initial begin
        file = $fopen("Comandos.txt", "r");
        if (file) begin
            while (!$feof(file)) begin
                $fscanf(file, "%d\n", M);
                $display("Código de operación leído: %d", M);
            end
            $fclose(file);
        end else begin
            $display("Error: No se pudo abrir el archivo.");
        end
    end
endmodule


