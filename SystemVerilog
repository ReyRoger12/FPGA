module ALU(
    input logic [31:0] A, B,    // Entradas A y B
    input logic [4:0]  OP,      // Código de operación
    output logic [31:0] Y       // Salida de la operación
);
    
    always_comb begin
        case (OP)
            5'd0:  Y = A + B;         // Suma
            5'd1:  Y = A - B;         // A - B
            5'd2:  Y = B - A;         // B - A
            5'd3:  Y = A & B;         // AND
            5'd4:  Y = A | B;         // OR
            5'd5:  Y = A ^ B;         // XOR
            5'd6:  Y = ~A;            // NOT A
            5'd7:  Y = ~B;            // NOT B
            5'd8:  Y = A * B;         // Multiplicación
            5'd9:  Y = B != 0 ? A / B : 32'hFFFFFFFF; // División (manejo de división por cero)
            5'd10: Y = A << 1;        // Desplazamiento a la izquierda
            5'd14: Y = fibonacci(A);  // Fibonacci de A
            5'd15: Y = factorial(A);  // Factorial de A
            5'd16: Y = power(A, B);   // A^B (potencia)
            5'd17: Y = B != 0 ? A % B : 32'hFFFFFFFF; // Módulo (manejo de división por cero)
            5'd18: Y = sqrt(A);       // Raíz cuadrada de A
            default: Y = 32'h0;       // Default: salida en cero
        endcase
    end

    // Función para calcular Fibonacci
    function automatic logic [31:0] fibonacci(input logic [31:0] n);
        logic [31:0] a, b, temp, i;
        a = 0; b = 1;
        for (i = 0; i < n; i = i + 1) begin
            temp = a + b;
            a = b;
            b = temp;
        end
        return a;
    endfunction

    // Función para calcular Factorial
    function automatic logic [31:0] factorial(input logic [31:0] n);
        logic [31:0] result, i;
        result = 1;
        for (i = 1; i <= n; i = i + 1)
            result = result * i;
        return result;
    endfunction

    // Función para calcular potencia A^B
    function automatic logic [31:0] power(input logic [31:0] base, exponent);
        logic [31:0] result;
        result = 1;
        while (exponent > 0) begin
            result = result * base;
            exponent = exponent - 1;
        end
        return result;
    endfunction

    // Función para calcular raíz cuadrada usando el método de Newton-Raphson
    function automatic logic [31:0] sqrt(input logic [31:0] n);
        logic [31:0] x, y;
        x = n;
        y = (x + 1) >> 1;
        while (y < x) begin
            x = y;
            y = (x + n / x) >> 1;
        end
        return x;
    endfunction

endmodule

